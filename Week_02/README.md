
1. 【1】两数之和
    1. 暴力、双指针、hash
2. 【26】删除排序数组中的重复项
    1. 暴力，从后遍历数组，调用splice
    2. 指针标记，遇到重复的，指针不动；遇到不重复的，指针+1
3. 【283】移动零
    1. 暴力解法，先删除0，然后末尾补0
    2. 指针标记，类似【26】删除排序数组中的重复项
4. 【36】有效的数独 (没什么好办法，反正硬解也是O(1))
5. 【404】左叶子之和               
    1.  DFS BFS. 只要找到左叶子即可，任何遍历方式都行，所以DFS BFS都可  
    2. 也提供一个经验，只要是树，所有遍历方式都可以想一遍。
6. 【104】二叉树的最大深度             
    1. DFS null层level为0，往上递归，每层level加1，直到根节点，得到最大深度level+1
    2. BFS 
        * 外层搞一个变量count计数，记录每层的size，队列里每出来size个元素，count++
        * 借鉴“【429】N叉树的层序遍历”，429是把每层的值放入一个子数组，然后把子数组放入大数组target[][]。最终target的长度就是最大深度。当然，本题不需要把值都放进子数组里，只需要让子数组存在即可，用个空数组标记就行了。
7. 【429】N叉树的层序遍历 
    1. 不是普通的层序遍历，它要求把每层作为一个数组返回。队列和递归都行。
        * 队列：把同一层的入队，队列取完了，同一层的就取完了，就得到了该层的数组。
        * 递归：把每层的level传进去，相同的level值属于同一层。
    2. 普通层序遍历只能用BFS，递归不合适。
8. 【面试题16.05】阶乘尾数(数学问题，寻找5的个数)            
9. 【面试题08.01】三步问题 (非递归的斐波拉契)         
10. 【258】各位相加 (数根，数学问题，无解啊，尽量理解并记忆，适应这类题目)      
11. 【412】Fizz Buzz     
